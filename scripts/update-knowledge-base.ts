/**
 * ISLE AI - Update Knowledge Base with Scraped Images
 *
 * This script reads the image mappings generated by scrape-images.ts
 * and updates the knowledge base TypeScript files with the new image URLs.
 *
 * Usage:
 *   npx ts-node scripts/update-knowledge-base.ts
 *   npx ts-node scripts/update-knowledge-base.ts --dry-run
 *   npx ts-node scripts/update-knowledge-base.ts --backup
 *
 * Input:
 *   - data/scraped-images/image-mappings.json
 *
 * Output:
 *   - Updated data/serpapi-vip-data.ts
 *   - Updated data/cayman-islands-knowledge.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// ESM compatibility for __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuration
const CONFIG = {
  MAPPINGS_FILE: path.join(__dirname, '../data/scraped-images/image-mappings.json'),
  SERPAPI_FILE: path.join(__dirname, '../data/serpapi-vip-data.ts'),
  KNOWLEDGE_FILE: path.join(__dirname, '../data/cayman-islands-knowledge.ts'),
  BACKUP_DIR: path.join(__dirname, '../data/backups'),
};

interface ImageMapping {
  thumbnail: string;
  images: string[];
}

interface UpdateStats {
  totalMappings: number;
  serpapiUpdated: number;
  knowledgeUpdated: number;
  errors: string[];
}

// Utility functions
function log(message: string, type: 'info' | 'success' | 'error' | 'warn' = 'info'): void {
  const timestamp = new Date().toISOString();
  const prefix = {
    info: '\x1b[36m[INFO]\x1b[0m',
    success: '\x1b[32m[SUCCESS]\x1b[0m',
    error: '\x1b[31m[ERROR]\x1b[0m',
    warn: '\x1b[33m[WARN]\x1b[0m',
  }[type];
  console.log(`${timestamp} ${prefix} ${message}`);
}

function ensureDirectoryExists(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    log(`Created directory: ${dirPath}`);
  }
}

function createBackup(filePath: string): string {
  ensureDirectoryExists(CONFIG.BACKUP_DIR);
  const fileName = path.basename(filePath);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupPath = path.join(CONFIG.BACKUP_DIR, `${fileName}.${timestamp}.bak`);
  fs.copyFileSync(filePath, backupPath);
  log(`Created backup: ${backupPath}`, 'success');
  return backupPath;
}

/**
 * Load image mappings from JSON file
 */
function loadImageMappings(): Record<string, ImageMapping> {
  if (!fs.existsSync(CONFIG.MAPPINGS_FILE)) {
    throw new Error(`Image mappings file not found: ${CONFIG.MAPPINGS_FILE}`);
  }
  const content = fs.readFileSync(CONFIG.MAPPINGS_FILE, 'utf-8');
  return JSON.parse(content);
}

/**
 * Escape special regex characters in a string
 */
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Update a single TypeScript file with new image URLs
 */
function updateFile(
  filePath: string,
  mappings: Record<string, ImageMapping>,
  isDryRun: boolean
): { updated: number; errors: string[] } {
  log(`Processing file: ${filePath}`);
  const result = { updated: 0, errors: [] as string[] };

  let content = fs.readFileSync(filePath, 'utf-8');
  const originalContent = content;

  for (const [nodeId, imageData] of Object.entries(mappings)) {
    // Skip if no thumbnail
    if (!imageData.thumbnail) continue;

    // Find the node in the file by ID
    // Pattern: "id": "nodeId" or id: 'nodeId'
    const idPatterns = [
      `"id":\\s*"${escapeRegex(nodeId)}"`,
      `id:\\s*'${escapeRegex(nodeId)}'`,
    ];

    let foundNode = false;
    for (const idPattern of idPatterns) {
      const idRegex = new RegExp(idPattern);
      if (idRegex.test(content)) {
        foundNode = true;
        break;
      }
    }

    if (!foundNode) {
      continue; // Node not in this file
    }

    log(`Found node ${nodeId} in file`);

    // Strategy 1: Update thumbnail URL directly
    // Match: "thumbnail": "old-url" or thumbnail: 'old-url'
    const thumbnailPatterns = [
      // JSON-style with double quotes
      {
        pattern: new RegExp(
          `("id":\\s*"${escapeRegex(nodeId)}"[\\s\\S]*?"thumbnail":\\s*)"([^"]*)"`,
          'g'
        ),
        replacement: `$1"${imageData.thumbnail}"`,
      },
      // TS-style with single quotes for id, double for thumbnail
      {
        pattern: new RegExp(
          `(id:\\s*'${escapeRegex(nodeId)}'[\\s\\S]*?thumbnail:\\s*)'([^']*)'`,
          'g'
        ),
        replacement: `$1'${imageData.thumbnail}'`,
      },
      // TS-style all double quotes
      {
        pattern: new RegExp(
          `(id:\\s*"${escapeRegex(nodeId)}"[\\s\\S]*?thumbnail:\\s*)"([^"]*)"`,
          'g'
        ),
        replacement: `$1"${imageData.thumbnail}"`,
      },
    ];

    for (const { pattern, replacement } of thumbnailPatterns) {
      const beforeReplace = content;
      content = content.replace(pattern, replacement);
      if (content !== beforeReplace) {
        result.updated++;
        log(`Updated thumbnail for ${nodeId}`, 'success');
        break;
      }
    }

    // Strategy 2: Update images array
    // This is more complex due to array formatting
    // For now, we'll focus on thumbnail updates which is the primary goal
    if (imageData.images && imageData.images.length > 0) {
      // Format images array
      const imagesArrayStr = JSON.stringify(imageData.images);

      // Try to replace the entire images array
      const imagesPatterns = [
        // JSON style
        {
          pattern: new RegExp(
            `("id":\\s*"${escapeRegex(nodeId)}"[\\s\\S]*?"images":\\s*)\\[[^\\]]*\\]`,
            'g'
          ),
          replacement: `$1${imagesArrayStr}`,
        },
        // TS style
        {
          pattern: new RegExp(
            `(id:\\s*['"]${escapeRegex(nodeId)}['"][\\s\\S]*?images:\\s*)\\[[^\\]]*\\]`,
            'g'
          ),
          replacement: `$1${imagesArrayStr}`,
        },
      ];

      for (const { pattern, replacement } of imagesPatterns) {
        const beforeReplace = content;
        content = content.replace(pattern, replacement);
        if (content !== beforeReplace) {
          log(`Updated images array for ${nodeId}`, 'success');
          break;
        }
      }
    }
  }

  // Check if any changes were made
  if (content !== originalContent) {
    if (isDryRun) {
      log(`[DRY RUN] Would update ${result.updated} nodes in ${path.basename(filePath)}`);
    } else {
      fs.writeFileSync(filePath, content, 'utf-8');
      log(`Saved updates to ${path.basename(filePath)}`, 'success');
    }
  } else {
    log(`No changes needed for ${path.basename(filePath)}`);
  }

  return result;
}

/**
 * Alternative approach: Generate a patch file
 */
function generatePatchFile(mappings: Record<string, ImageMapping>): void {
  const patchPath = path.join(CONFIG.BACKUP_DIR, 'image-updates.patch.ts');
  ensureDirectoryExists(CONFIG.BACKUP_DIR);

  let patchContent = `/**
 * Image URL Updates - Generated ${new Date().toISOString()}
 *
 * This file contains the mapping of node IDs to new image URLs.
 * To apply, manually update the corresponding nodes in:
 * - data/serpapi-vip-data.ts
 * - data/cayman-islands-knowledge.ts
 */

export const IMAGE_UPDATES: Record<string, { thumbnail: string; images: string[] }> = {\n`;

  for (const [nodeId, imageData] of Object.entries(mappings)) {
    if (imageData.thumbnail) {
      patchContent += `  '${nodeId}': {\n`;
      patchContent += `    thumbnail: '${imageData.thumbnail}',\n`;
      patchContent += `    images: ${JSON.stringify(imageData.images)},\n`;
      patchContent += `  },\n`;
    }
  }

  patchContent += `};\n`;

  fs.writeFileSync(patchPath, patchContent, 'utf-8');
  log(`Generated patch file: ${patchPath}`, 'success');
}

/**
 * Apply updates using AST-safe replacement
 * This approach is more robust for complex TypeScript files
 */
function applyUpdatesWithLineSearch(
  filePath: string,
  mappings: Record<string, ImageMapping>,
  isDryRun: boolean
): { updated: number; errors: string[] } {
  log(`Processing file with line search: ${filePath}`);
  const result = { updated: 0, errors: [] as string[] };

  const lines = fs.readFileSync(filePath, 'utf-8').split('\n');
  const updatedLines: string[] = [];

  let currentNodeId: string | null = null;
  let insideMedia = false;
  let braceDepth = 0;
  let mediaStartDepth = 0;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];

    // Track node ID
    const idMatch = line.match(/"id":\s*"([^"]+)"|id:\s*['"]([^'"]+)['"]/);
    if (idMatch) {
      currentNodeId = idMatch[1] || idMatch[2];
    }

    // Track brace depth
    const openBraces = (line.match(/\{/g) || []).length;
    const closeBraces = (line.match(/\}/g) || []).length;

    // Check if entering media object
    if (line.includes('"media"') || line.includes('media:')) {
      insideMedia = true;
      mediaStartDepth = braceDepth + openBraces;
    }

    braceDepth += openBraces - closeBraces;

    // Check if leaving media object
    if (insideMedia && braceDepth < mediaStartDepth) {
      insideMedia = false;
    }

    // Update thumbnail if we're in a media block and have a mapping
    if (
      currentNodeId &&
      mappings[currentNodeId] &&
      insideMedia &&
      (line.includes('"thumbnail"') || line.includes('thumbnail:'))
    ) {
      const newThumbnail = mappings[currentNodeId].thumbnail;

      // Replace the URL in the line
      const updatedLine = line.replace(
        /(["']?thumbnail["']?\s*:\s*["'])([^"']*)(["'])/,
        `$1${newThumbnail}$3`
      );

      if (updatedLine !== line) {
        line = updatedLine;
        result.updated++;
        log(`Line ${i + 1}: Updated thumbnail for ${currentNodeId}`, 'success');
      }
    }

    // Update images array
    if (
      currentNodeId &&
      mappings[currentNodeId] &&
      insideMedia &&
      (line.includes('"images"') || line.includes('images:')) &&
      mappings[currentNodeId].images.length > 0
    ) {
      // Check if it's a single-line array
      if (line.includes('[') && line.includes(']')) {
        const newImages = JSON.stringify(mappings[currentNodeId].images);
        const updatedLine = line.replace(
          /(["']?images["']?\s*:\s*)\[[^\]]*\]/,
          `$1${newImages}`
        );

        if (updatedLine !== line) {
          line = updatedLine;
          log(`Line ${i + 1}: Updated images array for ${currentNodeId}`, 'success');
        }
      }
    }

    updatedLines.push(line);
  }

  // Save changes
  const updatedContent = updatedLines.join('\n');
  const originalContent = fs.readFileSync(filePath, 'utf-8');

  if (updatedContent !== originalContent) {
    if (isDryRun) {
      log(`[DRY RUN] Would update ${result.updated} thumbnails in ${path.basename(filePath)}`);
    } else {
      fs.writeFileSync(filePath, updatedContent, 'utf-8');
      log(`Saved ${result.updated} updates to ${path.basename(filePath)}`, 'success');
    }
  } else {
    log(`No changes detected for ${path.basename(filePath)}`);
  }

  return result;
}

/**
 * Create an update function that can be used at runtime
 */
function generateRuntimeUpdater(mappings: Record<string, ImageMapping>): void {
  const updaterPath = path.join(__dirname, '../data/apply-image-updates.ts');

  const content = `/**
 * Runtime Image Updates
 * Generated: ${new Date().toISOString()}
 *
 * This module exports a function to apply image updates to knowledge nodes.
 * Import and use after loading your knowledge base.
 */

import type { KnowledgeNode } from '../types/chatbot';

export const IMAGE_MAPPINGS: Record<string, { thumbnail: string; images: string[] }> = ${JSON.stringify(mappings, null, 2)};

/**
 * Apply image updates to an array of knowledge nodes
 */
export function applyImageUpdates(nodes: KnowledgeNode[]): KnowledgeNode[] {
  return nodes.map(node => {
    const update = IMAGE_MAPPINGS[node.id];
    if (update) {
      return {
        ...node,
        media: {
          ...node.media,
          thumbnail: update.thumbnail || node.media.thumbnail,
          images: update.images.length > 0 ? update.images : node.media.images,
        },
      };
    }
    return node;
  });
}

/**
 * Apply image updates to a single knowledge node
 */
export function applyImageUpdate(node: KnowledgeNode): KnowledgeNode {
  const update = IMAGE_MAPPINGS[node.id];
  if (update) {
    return {
      ...node,
      media: {
        ...node.media,
        thumbnail: update.thumbnail || node.media.thumbnail,
        images: update.images.length > 0 ? update.images : node.media.images,
      },
    };
  }
  return node;
}

/**
 * Get update count
 */
export const TOTAL_UPDATES = Object.keys(IMAGE_MAPPINGS).length;
`;

  fs.writeFileSync(updaterPath, content, 'utf-8');
  log(`Generated runtime updater: ${updaterPath}`, 'success');
}

/**
 * Main entry point
 */
async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const isDryRun = args.includes('--dry-run');
  const createBackupFlag = args.includes('--backup');
  const generateUpdater = args.includes('--generate-updater');
  const patchOnly = args.includes('--patch-only');

  console.log('\n========================================');
  console.log('   ISLE AI - Update Knowledge Base');
  console.log('========================================\n');

  log(`Mode: ${isDryRun ? 'DRY RUN' : 'LIVE'}`);
  log(`Create Backups: ${createBackupFlag}`);

  // Load mappings
  let mappings: Record<string, ImageMapping>;
  try {
    mappings = loadImageMappings();
    log(`Loaded ${Object.keys(mappings).length} image mappings`, 'success');
  } catch (error) {
    log(`Failed to load mappings: ${error}`, 'error');
    log('Make sure to run scrape-images.ts first!', 'warn');
    process.exit(1);
  }

  // Generate runtime updater (recommended approach)
  if (generateUpdater || patchOnly) {
    generateRuntimeUpdater(mappings);
    generatePatchFile(mappings);

    if (patchOnly) {
      log('Patch-only mode: generated patch files without modifying source files');
      return;
    }
  }

  const stats: UpdateStats = {
    totalMappings: Object.keys(mappings).length,
    serpapiUpdated: 0,
    knowledgeUpdated: 0,
    errors: [],
  };

  // Create backups if requested
  if (createBackupFlag && !isDryRun) {
    if (fs.existsSync(CONFIG.SERPAPI_FILE)) {
      createBackup(CONFIG.SERPAPI_FILE);
    }
    if (fs.existsSync(CONFIG.KNOWLEDGE_FILE)) {
      createBackup(CONFIG.KNOWLEDGE_FILE);
    }
  }

  // Update serpapi-vip-data.ts
  if (fs.existsSync(CONFIG.SERPAPI_FILE)) {
    const result = applyUpdatesWithLineSearch(CONFIG.SERPAPI_FILE, mappings, isDryRun);
    stats.serpapiUpdated = result.updated;
    stats.errors.push(...result.errors);
  } else {
    log(`File not found: ${CONFIG.SERPAPI_FILE}`, 'warn');
  }

  // Update cayman-islands-knowledge.ts
  if (fs.existsSync(CONFIG.KNOWLEDGE_FILE)) {
    const result = applyUpdatesWithLineSearch(CONFIG.KNOWLEDGE_FILE, mappings, isDryRun);
    stats.knowledgeUpdated = result.updated;
    stats.errors.push(...result.errors);
  } else {
    log(`File not found: ${CONFIG.KNOWLEDGE_FILE}`, 'warn');
  }

  // Print summary
  console.log('\n========================================');
  console.log('   UPDATE COMPLETE');
  console.log('========================================\n');
  console.log(`Total Mappings: ${stats.totalMappings}`);
  console.log(`serpapi-vip-data.ts: ${stats.serpapiUpdated} nodes updated`);
  console.log(`cayman-islands-knowledge.ts: ${stats.knowledgeUpdated} nodes updated`);

  if (stats.errors.length > 0) {
    console.log(`\nErrors (${stats.errors.length}):`);
    stats.errors.forEach(err => console.log(`  - ${err}`));
  }

  // Recommend runtime updater approach
  console.log('\n----------------------------------------');
  console.log('RECOMMENDED: Use the runtime updater approach');
  console.log('Run: npx ts-node scripts/update-knowledge-base.ts --generate-updater');
  console.log('Then import applyImageUpdates from data/apply-image-updates.ts');
  console.log('----------------------------------------\n');
}

// Run the script
main().catch(error => {
  log(`Fatal error: ${error}`, 'error');
  process.exit(1);
});
